import os
import numpy as np
import pandas as pd
from math import e
from ast import literal_eval
from malwareDetector.detector import detector
from utils import set_dataset_description, get_ware_CPU_Arc
from multiprocessing import Pool, cpu_count


class Vectorize(detector):
    def __init__(self, config, df_dataset_discription):
        self.config = config
        self.df_dataset_discription = df_dataset_discription

    def make_folder(self):
        output_graph_dir = os.path.join(self.config.folder.vectorize, "graph")
        output_eigen_dir = os.path.join(self.config.folder.vectorize, "eigen")
        os.makedirs(output_graph_dir, exist_ok=True)
        os.makedirs(output_eigen_dir, exist_ok=True)

    def generateAGraph(self, file_name):
        set_dataset_description(self.df_dataset_discription)
        print(f"Graph Generating {file_name}...")
        graph_generator = GraphGenerator(self.config, file_name)
        graph_generator.generate_graph()
        print(f"Graph Generating {file_name} is done.")

    def generateVector(self, file_name):
        set_dataset_description(self.df_dataset_discription)
        print(f"Vectorizing {file_name}...")
        eigen_space = EigenSpaceGenerator(self.config, file_name)
        eigen_space.generate_eigen_space()
        print(f"Vectorizing {file_name} is done.")

    def vectorize(self):
        # make the folder
        self.make_folder()
        # generate the graph
        sample_file_list = os.listdir(self.config.folder.disassemble)
        with Pool(cpu_count()) as pool:
            pool.map(self.generateAGraph, sample_file_list)
        # generate the vector
        graph_file_list = os.listdir(
            os.path.join(self.config.folder.vectorize, "graph")
        )
        with Pool(cpu_count()) as pool:
            pool.map(self.generateVector, graph_file_list)


class GraphGenerator(detector):
    def __init__(self, config, file_name):
        self.config = config
        self.file_name = os.path.splitext(file_name)[0]
        self.input_file_path = os.path.join(
            self.config.folder.disassemble, f"{self.file_name}.csv"
        )
        self.output_file_path = os.path.join(
            self.config.folder.vectorize, "graph", f"{self.file_name}.npy"
        )
        self.feature_file_path = os.path.join(
            self.config.folder.feature,
            f"feature_{get_ware_CPU_Arc(self.file_name)}.csv",
        )
        self.df_sample = pd.read_csv(self.input_file_path)
        self.df_feature = self.get_feature()
        self.NUM_FEATURE = len(self.df_feature)
        self.SAMPLE_SIZE = len(self.df_sample)
        self.affinity_matrix = np.zeros((self.NUM_FEATURE, self.NUM_FEATURE))

    def get_feature(self):
        df = pd.read_csv(self.feature_file_path)
        return df["n-gram"].apply(literal_eval)

    def check_n_gram(self, idx):
        feature = self.df_feature.iloc[idx]
        selected_rows = self.df_sample.loc[
            self.df_sample["opcode"] == feature[0]
        ]
        idx_list = selected_rows.index
        for i in range(1, len(feature)):
            idx_list += 1
            idx_list = idx_list[idx_list < self.SAMPLE_SIZE]
            selected_rows = self.df_sample.loc[idx_list]
            idx_list = selected_rows[
                selected_rows["opcode"] == feature[i - 1]
            ].index
        return idx_list - len(feature) + 1

    def get_E_value(self, i, j):
        idx_list_i = np.array(self.check_n_gram(i))
        idx_list_j = np.array(self.check_n_gram(j))
        if not np.any(idx_list_i) or not np.any(idx_list_j):
            return 0
        diff = np.abs(
            np.min(idx_list_i[:, np.newaxis] - idx_list_j - 1, axis=1)
        )
        exp_diff = np.exp(np.clip(diff, -709, 709))
        exp_diff = np.where(exp_diff == -1, -0.999999, exp_diff)
        E_value = np.sum(2 / (1 + exp_diff))
        return E_value

    def get_affinity_matrix(self):
        self.affinity_matrix = np.fromfunction(
            np.vectorize(lambda i, j: self.get_E_value(i, j)),
            (self.NUM_FEATURE, self.NUM_FEATURE),
            dtype=int,
        )

    def row_normalize(self):
        row_norms = np.linalg.norm(self.affinity_matrix, axis=1, keepdims=True)
        row_norms = np.where(row_norms == 0, 1, row_norms)
        self.affinity_matrix /= row_norms

    def save_affinity_matrix(self):
        np.save(self.output_file_path, self.affinity_matrix)

    def generate_graph(self):
        self.get_affinity_matrix()
        self.row_normalize()
        self.save_affinity_matrix()


class EigenSpaceGenerator(detector):
    def __init__(self, config, file_name):
        self.config = config
        self.matrix = np.load(
            os.path.join(self.config.folder.vectorize, "graph", file_name)
        )
        self.output_file_path = os.path.join(
            self.config.folder.vectorize, "eigen", file_name
        )

    def get_eigen_pair(self):
        # calculate the eigenvalues and the eigenvectors
        eigenvalues, eigenvectors = np.linalg.eig(self.matrix)
        # Pair eigenvalues ​​and eigenvectors and sort them in descending order based on eigenvalues
        eig_pairs = [
            (np.abs(eigenvalues[i]), eigenvectors[:, i])
            for i in range(len(eigenvalues))
        ]
        eig_pairs.sort(key=lambda x: x[0], reverse=True)
        return eig_pairs[0], eig_pairs[1]

    # vector: [first_eigenvalue, second_eigenvalue, first_eigenvector, second_eigenvector]
    def generate_eigen_space(self):
        first_eigen_pair, second_eigen_pair = self.get_eigen_pair()
        vector = np.concatenate(
            (
                np.array([first_eigen_pair[0], second_eigen_pair[0]]),
                first_eigen_pair[1],
                second_eigen_pair[1],
            )
        )
        np.save(self.output_file_path, vector)
