import os
from ast import literal_eval
from multiprocessing import Pool, cpu_count

import numpy as np
import pandas as pd


class Vectorize:
    """
    Vectorize class to handle the vectorization of binary files.

    Attributes:
        config (Config): Configuration object containing necessary settings.
        df_dataset_discription (pd.DataFrame): DataFrame containing dataset description.
    """

    def __init__(self, config):
        """
        Initialize the Vectorize class with configuration and dataset description.

        Args:
            config (Config): Configuration object containing necessary settings.
            df_dataset_discription (pd.DataFrame): DataFrame containing dataset description.
        """
        self.config = config

    def _make_folder(self):
        """
        Create necessary folders for storing graph and eigen vector files.
        """
        output_graph_dir = os.path.join(self.config.folder.vectorize, "graph")
        output_eigen_dir = os.path.join(self.config.folder.vectorize, "eigen")
        os.makedirs(output_graph_dir, exist_ok=True)
        os.makedirs(output_eigen_dir, exist_ok=True)

    def _generate_graph(self, file_name):
        """
        Generate a graph for a given binary file.

        Args:
            file_name (str): Name of the binary file.
        """
        print(f"Graph Generating {file_name}...")
        graph_generator = GraphGenerator(self.config, file_name)
        graph_generator.run()
        print(f"Graph Generating {file_name} is done.")

    def _generate_vector(self, file_name):
        """
        Generate a vector for a given graph file.

        Args:
            file_name (str): Name of the graph file.
        """
        print(f"Vectorizing {file_name}...")
        eigen_space = EigenSpaceGenerator(self.config, file_name)
        eigen_space.run()
        print(f"Vectorizing {file_name} is done.")

    def run(self):
        """
        Run the vectorization process: generate graphs and vectors for the binary files.
        """
        self._make_folder()
        # generate the graph
        file_list = self.config.model.label_manager.filter_files()
        sample_file_list = [
            os.path.join(self.config.folder.disassemble, file_name)
            for file_name in file_list
        ]
        with Pool(cpu_count()) as pool:
            pool.map(self._generate_graph, sample_file_list)
        # generate the vector
        graph_file_list = [
            os.path.join(self.config.folder.vectorize, "graph", file_name)
            for file_name in file_list
        ]
        with Pool(cpu_count()) as pool:
            pool.map(self._generate_vector, graph_file_list)


class GraphGenerator:
    """
    GraphGenerator class to handle the generation of affinity matrices from binary files.

    Attributes:
        config (Config): Configuration object containing necessary settings.
        file_name (str): Name of the binary file.
        input_file_path (str): Path to the input binary file.
        output_file_path (str): Path to save the generated affinity matrix.
        feature_file_path (str): Path to the feature file.
        df_sample (pd.DataFrame): DataFrame containing the disassembled binary file.
        df_feature (pd.DataFrame): DataFrame containing the features.
        NUM_FEATURE (int): Number of features.
        SAMPLE_SIZE (int): Size of the sample.
        affinity_matrix (np.ndarray): Affinity matrix.
    """

    def __init__(self, config, file_name):
        """
        Initialize the GraphGenerator class with configuration and file name.

        Args:
            config (Config): Configuration object containing necessary settings.
            file_name (str): Name of the binary file.
        """
        self.config = config
        self.file_name = os.path.splitext(file_name)[0]
        self.input_file_path = os.path.join(
            self.config.folder.disassemble, f"{self.file_name}.csv"
        )
        self.output_file_path = os.path.join(
            self.config.folder.vectorize, "graph", f"{self.file_name}.npy"
        )
        self.feature_file_path = os.path.join(
            self.config.folder.feature,
            self.config.model.feature_file_name.format(
                ca=self.config.model.label_manager.get_file_info(
                    self.file_name, "CPUArchitecture"
                ),
                id=self.config.path.identifier,
            ),
        )
        self.df_sample = pd.read_csv(self.input_file_path)
        self.df_feature = self._get_feature()
        self.NUM_FEATURE = len(self.df_feature)
        self.SAMPLE_SIZE = len(self.df_sample)
        self.affinity_matrix = np.zeros((self.NUM_FEATURE, self.NUM_FEATURE))

    def _get_feature(self):
        """
        Get the features from the feature file.

        Returns:
            pd.DataFrame: DataFrame containing the features.
        """
        df = pd.read_csv(self.feature_file_path)
        return df["n-gram"].apply(literal_eval)

    def _check_n_gram(self, idx):
        """
        Check the n-gram occurrences in the sample.

        Args:
            idx (int): Index of the feature.

        Returns:
            np.ndarray: Indices of n-gram occurrences.
        """
        feature = self.df_feature.iloc[idx]
        selected_rows = self.df_sample.loc[self.df_sample["opcode"] == feature[0]]
        idx_list = selected_rows.index
        for i in range(1, len(feature)):
            idx_list += 1
            idx_list = idx_list[idx_list < self.SAMPLE_SIZE]
            selected_rows = self.df_sample.loc[idx_list]
            idx_list = selected_rows[selected_rows["opcode"] == feature[i - 1]].index
        return idx_list - len(feature) + 1

    def _get_E_value(self, i, j):
        """
        Calculate the E value for the affinity matrix.

        Args:
            i (int): Index of the first feature.
            j (int): Index of the second feature.

        Returns:
            float: E value.
        """
        idx_list_i = np.array(self._check_n_gram(i))
        idx_list_j = np.array(self._check_n_gram(j))
        if not np.any(idx_list_i) or not np.any(idx_list_j):
            return 0
        diff = np.abs(np.min(idx_list_i[:, np.newaxis] - idx_list_j - 1, axis=1))
        exp_diff = np.exp(np.clip(diff, -709, 709))
        exp_diff = np.where(exp_diff == -1, -0.999999, exp_diff)
        E_value = np.sum(2 / (1 + exp_diff))
        return E_value

    def _get_affinity_matrix(self):
        """
        Generate the affinity matrix.
        """
        self.affinity_matrix = np.fromfunction(
            np.vectorize(lambda i, j: self._get_E_value(i, j)),
            (self.NUM_FEATURE, self.NUM_FEATURE),
            dtype=int,
        )

    def _row_normalize(self):
        """
        Normalize the rows of the affinity matrix.
        """
        row_norms = np.linalg.norm(self.affinity_matrix, axis=1, keepdims=True)
        row_norms = np.where(row_norms == 0, 1, row_norms)
        self.affinity_matrix /= row_norms

    def _save_affinity_matrix(self):
        """
        Save the affinity matrix to a file.
        """
        np.save(self.output_file_path, self.affinity_matrix)

    def run(self):
        """
        Run the graph generation process.
        """
        self._get_affinity_matrix()
        self._row_normalize()
        self._save_affinity_matrix()


class EigenSpaceGenerator:
    """
    EigenSpaceGenerator class to handle the generation of eigenvectors from affinity matrices.

    Attributes:
        config (Config): Configuration object containing necessary settings.
        matrix (np.ndarray): Affinity matrix.
        output_file_path (str): Path to save the eigenvector file.
    """

    def __init__(self, config, file_name):
        """
        Initialize the EigenSpaceGenerator class with configuration and file name.

        Args:
            config (Config): Configuration object containing necessary settings.
            file_name (str): Name of the graph file.
        """
        self.config = config
        self.matrix = np.load(
            os.path.join(self.config.folder.vectorize, "graph", file_name)
        )
        self.output_file_path = os.path.join(
            self.config.folder.vectorize, "eigen", file_name
        )

    def _get_eigen_pair(self):
        """
        Calculate the eigenvalues and eigenvectors of the affinity matrix.

        Returns:
            tuple: Two eigenvalue-eigenvector pairs with the highest eigenvalues.
        """
        eigenvalues, eigenvectors = np.linalg.eig(self.matrix)
        # Pair eigenvalues ​​and eigenvectors and sort them in descending order based on eigenvalues
        eig_pairs = [
            (np.abs(eigenvalues[i]), eigenvectors[:, i])
            for i in range(len(eigenvalues))
        ]
        eig_pairs.sort(key=lambda x: x[0], reverse=True)
        return eig_pairs[0], eig_pairs[1]

    # vector: [first_eigenvalue, second_eigenvalue, first_eigenvector, second_eigenvector]
    def run(self):
        """
        Generate the eigenvector file from the affinity matrix.
        """
        first_eigen_pair, second_eigen_pair = self._get_eigen_pair()
        vector = np.concatenate(
            (
                np.array([first_eigen_pair[0], second_eigen_pair[0]]),
                first_eigen_pair[1],
                second_eigen_pair[1],
            )
        )
        np.save(self.output_file_path, vector)
