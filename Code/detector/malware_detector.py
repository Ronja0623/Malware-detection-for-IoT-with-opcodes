import os
import time

import pandas as pd
import torch
from malwareDetector.detector import detector

from models.enhanced_lenet import EnhancedLeNet
from utils import LogManager

from .extract_feature import ExtractFeature
from .preprocess import Preprocess
from .train_model import DataProcessor, ModelTrainer
from .util import set_dataset_description, set_ware_num
from .vectorize import Vectorize


class subDetector(detector):
    def __init__(self) -> None:
        # due to the existence of the json, call read_config()
        super().__init__()
        # set the path
        """if not os.path.exists("Disassemble"):
            self.config.folder.set_folder("disassemble", "Disassemble")
        if not os.path.exists("Log"):
            self.config.folder.set_folder("log", "log")
        """
        # set utils: all the info about the dataset should be get from utils
        self.dataset_description_path = os.path.join(
            self.config.folder.dataset, "dataset.csv"
        )
        self.df_dataset_discription = pd.read_csv(self.dataset_description_path)
        set_dataset_description(self.df_dataset_discription)
        # constants
        NUM_BENIGNWARE, NUM_MALWARE = set_ware_num()
        self.config.model.set_param("NUM_BENIGNWARE", NUM_BENIGNWARE)
        self.config.model.set_param("NUM_MALWARE", NUM_MALWARE)
        self.config.model.set_param("WARETYPE", ["benignware", "malware"])
        self.config.model.set_param("CPU_ARC", ["ARM", "MIPS", "PowerPC"])
        # set parameters about model training
        self.config.model.set_param("n", 2)  # n(n-gram)
        self.config.model.set_param("feature_selection_rate", 0.001)

    def preprocess(self) -> None:
        prep = Preprocess(self.config)
        prep.run(os.listdir(os.path.join(self.config.folder.dataset, "data")))

    def extractFeature(self):
        ef = ExtractFeature(self.config)
        ef.run()

    def vectorize(self):
        vect = Vectorize(self.config, self.df_dataset_discription)
        vect.run()

    def model(self, training: bool = True):
        """
        if `training=True`
            Train the model using the vectorized information.
        if `training=False`
            Use a pre-trained model. Note that this step will fail if no model has been trained.
        """
        for ca in self.config.model.CPU_ARC:
            print(f"CPU Architecture: {ca}")
            # Set the path
            timestamp = time.strftime("%Y%m%d_%H%M", time.localtime())
            self.LOG_DIR = r"D:\Code\Senior project\Log"
            model_path = os.path.join(self.config.folder.model, timestamp)
            os.makedirs(model_path, exist_ok=True)
            metrics_path = os.path.join(self.LOG_DIR, f"metrics_{timestamp}.csv")
            model_description_path = os.path.join(
                self.LOG_DIR, f"model_description_{timestamp}.txt"
            )
            # Set the model
            data_processor = DataProcessor(
                os.path.join(self.config.folder.vectorize, "eigen")
            )
            # num_classes = data_processor.get_num_classes("label")
            num_classes = 2
            model = EnhancedLeNet(num_classes)
            # model = BasicCNN(num_classes)
            # model = CustomVGG16(num_classes)
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            train_loader, val_loader, test_loader = data_processor.get_data_loader(
                model,
                self.dataset_description_path,
                # self.config.model.batch_size,
            )
            """log_manager = LogManager()
            model_trainer = ModelTrainer(
                model,
                log_manager,
                device,
                # self.LEARNING_RATE,
                # self.EPOCHS,
            )
            model_trainer.train(train_loader, val_loader, model_path)
            model_trainer.test(test_loader)
            log_manager.save_metrics(metrics_path)
            log_manager.save_model_description(
                model_description_path,
                model,
                self.BATCH_SIZE,
                self.LEARNING_RATE,
                self.EPOCHS,
            )"""

    """
    def predict(self):
        return 'This is the implementation of the predict function from the derived class.'
    """
