import os
import pandas as pd
from malwareDetector.detector import detector

# from rescue_utils import rescueUtils
from preprocess import Preprocess
from extract_feature import ExtractFeature
from vectorize import Vectorize
from train_model import Model, BasicCNN
from utils import set_dataset_description, set_ware_num


class subDetector(detector):
    def __init__(self) -> None:
        # due to the existence of the json, call read_config()
        super().__init__()
        # set the path
        if not os.path.exists("Disassemble"):
            self.config.folder.set_folder("disassemble", "Disassemble")
        if not os.path.exists("Report"):
            self.config.folder.set_folder("report", "Report")
        # set utils: all the info about the dataset should be get from utils
        self.df_dataset_discription = pd.read_csv(
            os.path.join(self.config.folder.dataset, "dataset.csv")
        )
        set_dataset_description(self.df_dataset_discription)
        # constants
        NUM_BENIGNWARE, NUM_MALWARE = set_ware_num()
        self.config.model.set_param("NUM_BENIGNWARE", NUM_BENIGNWARE)
        self.config.model.set_param("NUM_MALWARE", NUM_MALWARE)
        self.config.model.set_param("WARETYPE", ["benignware", "malware"])
        self.config.model.set_param("CPU_ARC", ["ARM", "MIPS", "PowerPC"])
        # set parameters about model training
        self.config.model.set_param("n", 2)  # n(n-gram)
        self.config.model.set_param("feature_selection_rate", 0.001)

    def preprocess(self) -> None:
        prep = Preprocess(self.config)
        prep.preprocess(
            os.listdir(os.path.join(self.config.folder.dataset, "data"))
        )

    def extractFeature(self):
        ef = ExtractFeature(self.config)
        ef.extract_feature()

    def vectorize(self):
        vect = Vectorize(self.config, self.df_dataset_discription)
        vect.vectorize()

    def model(self, training: bool = True):
        """
        if `training=True`
            Train the model using the vectorized information.
        if `training=False`
            Use a pre-trained model. Note that this step will fail if no model has been trained.
        """
        for ca in self.config.model.CPU_ARC:
            print(f"CPU Architecture: {ca}")
            # Set the path
            timestamp = time.strftime("%Y%m%d_%H%M", time.localtime())
            model_path = os.path.join(self.MODEL_DIR, timestamp)
            os.makedirs(model_path, exist_ok=True)
            metrics_path = os.path.join(
                self.LOG_DIR, f"metrics_{timestamp}.csv"
            )
            model_description_path = os.path.join(
                self.LOG_DIR, f"model_description_{timestamp}.txt"
            )
            # Set the model
            data_processor = DataProcessor(self.FLOW_DATASET_DIR)
            num_classes = data_processor.get_num_classes()
            model = EnhancedLeNet(num_classes)
            # model = BasicCNN(num_classes)
            # model = CustomVGG16(num_classes)
            device = torch.device(
                "cuda" if torch.cuda.is_available() else "cpu"
            )
            train_loader, val_loader, test_loader = (
                data_processor.get_data_loader(
                    self.BATCH_SIZE, model.image_size
                )
            )
            log_manager = LogManger()
            model_trainer = ModelTrainer(
                model,
                log_manager,
                device,
                self.LEARNING_RATE,
                self.EPOCHS,
            )
            model_trainer.train(train_loader, val_loader, model_path)
            model_trainer.test(test_loader)
            log_manager.save_metrics(metrics_path)
            log_manager.save_model_description(
                model_description_path,
                model,
                self.BATCH_SIZE,
                self.LEARNING_RATE,
                self.EPOCHS,
            )

    """
    def predict(self):
        return 'This is the implementation of the predict function from the derived class.'
    """


if __name__ == "__main__":
    myDetector = subDetector()
    myDetector.mkdir()
    # myDetector.preprocess()
    """
    ru = rescueUtils(myDetector.config)
    while ru.check_fully_disassemble(myDetector.file_list):
        unprep_list = ru.check_fully_disassemble(myDetector.file_list)
        prep = Preprocess(myDetector.config)
        prep.preprocess(unprep_list)
        print(f'Unpreprocessed list: {unprep_list}')"""
    # myDetector.extractFeature()
    myDetector.vectorize()
    # myDetector.model()
