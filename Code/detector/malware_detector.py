import os
import time

import pandas as pd
import torch
from malwareDetector.detector import detector

from models.enhanced_lenet import EnhancedLeNet
from utils import LogManager

from .extract_feature import ExtractFeature
from .predict import Predictor
from .preprocess import Preprocess
from .train_model import DataProcessor, ModelTrainer
from .util import set_dataset_description, set_ware_num
from .vectorize import Vectorize


class subDetector(detector):
    """
    subDetector class inheriting from detector to handle the malware detection process.

    Attributes:
        dataset_description_path (str): Path to the dataset description file.
        df_dataset_discription (pd.DataFrame): DataFrame containing dataset description.
    """

    def __init__(self) -> None:
        """
        Initialize the subDetector class, set up configuration, and constants.
        """
        super().__init__()
        # set the path
        """if not os.path.exists("Disassemble"):
            self.config.folder.set_folder("disassemble", "Disassemble")
        if not os.path.exists("Log"):
            self.config.folder.set_folder("log", "log")
        """
        # set utils: all the info about the dataset should be get from utils
        self.dataset_description_path = os.path.join(
            self.config.folder.dataset, "dataset.csv"
        )
        self.df_dataset_discription = pd.read_csv(self.dataset_description_path)
        set_dataset_description(self.df_dataset_discription)
        # constants
        NUM_BENIGNWARE, NUM_MALWARE = set_ware_num()
        self.config.model.set_param("NUM_BENIGNWARE", NUM_BENIGNWARE)
        self.config.model.set_param("NUM_MALWARE", NUM_MALWARE)
        self.config.model.set_param("WARETYPE", ["benignware", "malware"])
        self.config.model.set_param("CPU_ARC", ["ARM", "MIPS", "PowerPC"])
        # set parameters about model training
        self.config.model.set_param("n", 2)  # n(n-gram)
        self.config.model.set_param("feature_selection_rate", 0.001)

    def preprocess(self) -> None:
        """
        Run the preprocessing step to prepare data for feature extraction.
        """
        prep = Preprocess(self.config)
        prep.run(os.listdir(os.path.join(self.config.folder.dataset, "data")))

    def extractFeature(self) -> None:
        """
        Run the feature extraction process.
        """
        ef = ExtractFeature(self.config)
        ef.run()

    def vectorize(self) -> None:
        """
        Run the vectorization process on the dataset.
        """
        vect = Vectorize(self.config, self.df_dataset_discription)
        vect.run()

    def model(self, training: bool = True) -> None:
        """
        Train or load a pre-trained model based on the `training` flag.

        Args:
            training (bool): If True, train a new model. If False, load a pre-trained model.
        """
        for ca in self.config.model.CPU_ARC:
            print(f"CPU Architecture: {ca}")
            # Set the path
            timestamp = time.strftime("%Y%m%d_%H%M", time.localtime())
            self.LOG_DIR = r"D:\Code\Senior project\Log"
            model_path = os.path.join(self.config.folder.model, timestamp)
            os.makedirs(model_path, exist_ok=True)
            metrics_path = os.path.join(self.LOG_DIR, f"metrics_{timestamp}.csv")
            model_description_path = os.path.join(
                self.LOG_DIR, f"model_description_{timestamp}.txt"
            )

            data_processor = DataProcessor(
                os.path.join(self.config.folder.vectorize, "eigen")
            )
            # num_classes = data_processor.get_num_classes("label")
            num_classes = 2
            model = EnhancedLeNet(num_classes)
            # model = BasicCNN(num_classes)
            # model = CustomVGG16(num_classes)
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            train_loader, val_loader, test_loader = data_processor.get_data_loader(
                model,
                self.dataset_description_path,
                # self.config.model.batch_size,
            )
            """
            log_manager = LogManager()
            model_trainer = ModelTrainer(
                model,
                log_manager,
                device,
                # self.LEARNING_RATE,
                # self.EPOCHS,
            )
            model_trainer.train(train_loader, val_loader, model_path)
            model_trainer.test(test_loader)
            log_manager.save_metrics(metrics_path)
            log_manager.save_model_description(
                model_description_path,
                model,
                self.BATCH_SIZE,
                self.LEARNING_RATE,
                self.EPOCHS,
            )
            """

    def predict(self, model_path: str, data_list: list) -> list:
        """
        Predict the class labels for the given data using a pre-trained model.

        Args:
            model_path (str): Path to the pre-trained model file.
            data_list (list): List of data samples to predict.

        Returns:
            list: List of predictions for the given data samples.
        """
        predictor = Predictor(self.config, self.df_dataset_discription)
        predictor.load_model(model_path)
        data_loader = predictor.preprocess_data(data_list)
        predictions = predictor.predict(data_loader)
        return predictions
